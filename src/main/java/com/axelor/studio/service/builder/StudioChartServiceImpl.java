/*
 * Axelor Business Solutions
 *
 * Copyright (C) 2022 Axelor (<http://axelor.com>).
 *
 * This program is free software: you can redistribute it and/or  modify
 * it under the terms of the GNU Affero General Public License, version 3,
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.axelor.studio.service.builder;

import static com.axelor.utils.MetaJsonFieldType.JSON_MANY_TO_ONE;
import static com.axelor.utils.MetaJsonFieldType.MANY_TO_ONE;
import static com.axelor.utils.MetaJsonFieldType.ONE_TO_ONE;

import com.axelor.common.Inflector;
import com.axelor.i18n.I18n;
import com.axelor.inject.Beans;
import com.axelor.meta.CallMethod;
import com.axelor.meta.db.MetaField;
import com.axelor.meta.db.MetaJsonField;
import com.axelor.meta.db.MetaJsonRecord;
import com.axelor.meta.db.MetaModel;
import com.axelor.meta.db.MetaView;
import com.axelor.meta.db.repo.MetaModelRepository;
import com.axelor.meta.loader.XMLViews;
import com.axelor.meta.schema.ObjectViews;
import com.axelor.studio.db.Filter;
import com.axelor.studio.db.StudioChart;
import com.axelor.studio.exception.StudioExceptionMessage;
import com.axelor.studio.service.StudioMetaService;
import com.axelor.studio.service.filter.FilterCommonService;
import com.axelor.studio.service.filter.FilterSqlService;
import com.google.common.base.Joiner;
import com.google.inject.Inject;
import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.xml.bind.JAXBException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class generate charts using ViewBuilder and chart related fields. Chart xml generated by
 * adding query, search fields , onInit actions..etc. All filters with parameter checked will be
 * used as search fields.
 */
public class StudioChartServiceImpl implements StudioChartService {

  protected final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());

  protected static final String Tab1 = "\n \t";
  protected static final String Tab2 = "\n \t\t";
  protected static final String Tab3 = "\n \t\t\t";
  protected static final List<String> dateTypes =
      Arrays.asList(
          new String[] {"DATE", "DATETIME", "LOCALDATE", "LOCALDATETIME", "ZONNEDDATETIME"});
  protected static final List<String> CLICK_HANDLER_SUPPORTED_CHARTS =
      Arrays.asList("bar", "hbar", "scatter", "pie", "donut");

  protected List<String> searchFields;

  //	private List<RecordField> onNewFields;

  protected List<String> joins;

  protected String categType;

  protected MetaModelRepository metaModelRepo;

  protected FilterCommonService filterCommonService;

  protected StudioMetaService metaService;

  @Inject
  public StudioChartServiceImpl(
      MetaModelRepository metaModelRepo,
      FilterCommonService filterCommonService,
      StudioMetaService metaService) {
    this.metaModelRepo = metaModelRepo;
    this.filterCommonService = filterCommonService;
    this.metaService = metaService;
  }

  /**
   * Root Method to access the service it generate AbstractView from ViewBuilder.
   *
   * @param studioChart StudioChart object.
   * @throws JAXBException
   */
  @Override
  public void build(StudioChart studioChart) throws JAXBException {

    if (studioChart.getName().contains(" ")) {
      throw new IllegalStateException(I18n.get(StudioExceptionMessage.STUDIO_CHART_1));
    }

    searchFields = new ArrayList<String>();
    //		onNewFields = new ArrayList<RecordField>();
    joins = new ArrayList<String>();
    categType = "text";

    String[] queryString = prepareQuery(studioChart);
    //		setOnNewAction(studioChart);

    String xml = createXml(studioChart, queryString);

    log.debug("Chart xml: {}", xml);

    ObjectViews chartView = XMLViews.fromXML(xml);

    MetaView metaView = metaService.generateMetaView(chartView.getViews().get(0));

    if (metaView != null) {
      studioChart.setMetaViewGenerated(metaView);
    }
  }

  @Override
  public String createXml(StudioChart studioChart, String[] queryString) {

    String xml =
        "<chart name=\"" + studioChart.getName() + "\" title=\"" + studioChart.getTitle() + "\" ";

    //		if (onNewAction != null) {
    //			xml += " onInit=\"" + onNewAction.getName() + "\" ";
    //		}

    xml += ">\n";

    if (!searchFields.isEmpty()) {
      xml += "\t" + getSearchFields() + "\n";
    }

    String groupLabel =
        studioChart.getIsJsonGroupOn()
            ? studioChart.getGroupOnJson().getTitle()
            : studioChart.getGroupOn().getLabel();

    String displayLabel =
        studioChart.getIsJsonDisplayField()
            ? studioChart.getDisplayFieldJson().getTitle()
            : studioChart.getDisplayField().getLabel();

    xml += "\t<dataset type=\"sql\"><![CDATA[";
    xml += Tab2 + queryString[0];
    xml += Tab2 + " ]]></dataset>";
    xml +=
        Tab1
            + "<category key=\"group_field\" type=\""
            + categType
            + "\" title=\""
            + groupLabel
            + "\" />";
    xml +=
        Tab1
            + "<series key=\"sum_field\" type=\""
            + studioChart.getChartType()
            + "\" title=\""
            + displayLabel
            + "\" ";
    if (queryString[1] != null) {
      xml += "groupBy=\"agg_field\" ";
    }
    xml += "/>\n";

    if (CLICK_HANDLER_SUPPORTED_CHARTS.contains(studioChart.getChartType())) {
      xml += "<config name=\"onClick\" value=\"action-studio-chart-view-related-record\" />";
    }

    xml += "</chart>";

    return xml;
  }

  /**
   * Method create query from chart filters added in chart builder.
   *
   * @param studioChart StudioChart to use.
   * @return StringArray with first element as query string and second as aggregate field name.
   */
  @Override
  public String[] prepareQuery(StudioChart studioChart) {

    String query =
        createSumQuery(
            studioChart.getIsJsonDisplayField(),
            studioChart.getDisplayField(),
            studioChart.getDisplayFieldJson());

    String groupField =
        getGroup(
            studioChart.getIsJsonGroupOn(),
            studioChart.getGroupOn(),
            studioChart.getGroupOnJson(),
            studioChart.getGroupDateType(),
            studioChart.getGroupOnTarget());

    String aggField =
        getGroup(
            studioChart.getIsJsonAggregateOn(),
            studioChart.getAggregateOn(),
            studioChart.getAggregateOnJson(),
            studioChart.getAggregateDateType(),
            studioChart.getAggregateOnTarget());

    query += groupField + " AS group_field";

    if (aggField != null) {
      query += "," + Tab3 + aggField + " AS agg_field";
    }

    String filters =
        Beans.get(FilterSqlService.class).getSqlFilters(studioChart.getFilterList(), joins, true);
    addSearchField(studioChart.getFilterList());
    String model = studioChart.getModel();

    if (studioChart.getIsJson()) {
      if (filters != null) {
        filters = "self.json_model = '" + model + "' AND (" + filters + ")";
      } else {
        filters = "self.json_model = '" + model + "'";
      }
      model = MetaJsonRecord.class.getName();
    }

    query += Tab2 + "FROM " + Tab3 + getTable(model) + " self";

    if (!joins.isEmpty()) {
      query += Tab3 + Joiner.on(Tab3).join(joins);
    }

    if (filters != null) {
      query += Tab2 + "WHERE " + Tab3 + filters;
    }

    query += Tab2 + "group by " + Tab3 + "group_field";

    if (aggField != null && aggField != null) {
      query += ",agg_field";
      return new String[] {query, aggField};
    }

    return new String[] {query, null};
  }

  @Override
  public String createSumQuery(boolean isJson, MetaField metaField, MetaJsonField jsonField) {

    String sumField = null;
    FilterSqlService filterSqlService = Beans.get(FilterSqlService.class);

    if (isJson) {
      String sqlType = filterSqlService.getSqlType(jsonField.getType());
      sumField =
          "cast(self."
              + filterSqlService.getColumn(jsonField.getModel(), jsonField.getModelField())
              + "->>'"
              + jsonField.getName()
              + "' as "
              + sqlType
              + ")";
    } else {
      sumField = "self." + filterSqlService.getColumn(metaField);
    }

    return "SELECT" + Tab3 + "SUM(" + sumField + ") AS sum_field," + Tab3;
  }

  @Override
  public String getGroup(
      boolean isJson,
      MetaField metaField,
      MetaJsonField jsonField,
      String dateType,
      String target) {

    if (!isJson && metaField == null || isJson && jsonField == null) {
      return null;
    }

    FilterSqlService filterSqlService = Beans.get(FilterSqlService.class);

    String typeName = null;
    String group = null;
    Object object = null;
    StringBuilder parent = new StringBuilder("self");
    if (isJson) {
      group = jsonField.getName();
      typeName = filterSqlService.getSqlType(jsonField.getType());
      if (target != null) {
        object = filterSqlService.parseJsonField(jsonField, target, joins, parent);
      }
    } else {
      group = filterSqlService.getColumn(metaField);
      typeName = filterSqlService.getSqlType(metaField.getTypeName());
      if (target != null) {
        object = filterSqlService.parseMetaField(metaField, target, joins, parent, true);
      }
    }

    if (object != null) {
      String[] sqlField = filterSqlService.getSqlField(object, parent.toString(), joins);
      typeName = sqlField[1];
      group = sqlField[0];
    }

    log.debug("Group field type: {}, group: {}, dateType: {}", typeName, group, dateType);

    if (dateType != null && typeName != null && dateTypes.contains(typeName.toUpperCase())) {
      group = getDateTypeGroup(dateType, typeName, group);
    }

    return group;
  }

  @Override
  public String getDateTypeGroup(String dateType, String typeName, String group) {

    switch (dateType) {
      case "year":
        group = "to_char(cast(" + group + " as date), 'yyyy')";
        break;
      case "month":
        group = "to_char(cast(" + group + " as date), 'yyyy-mm')";
        break;
      default:
        categType = "date";
    }

    return group;
  }

  /**
   * Method generate xml for search-fields.
   *
   * @return
   */
  @Override
  public String getSearchFields() {

    String search = "<search-fields>";

    int count = 0;

    for (String searchField : searchFields) {
      search += Tab2 + searchField;
      if (++count == 2) {
        break;
      }
    }

    search += Tab1 + "</search-fields>";

    return search;
  }

  @Override
  public void addSearchField(List<Filter> filters) {

    if (filters == null) {
      return;
    }

    FilterSqlService filterSqlService = Beans.get(FilterSqlService.class);

    filters.stream()
        .filter(filter -> filter.getIsParameter())
        .forEach(
            filter -> {
              String fieldStr = "param" + filter.getId();

              Object object = null;
              StringBuilder parent = new StringBuilder("self");
              if (filter.getIsJson()) {
                object =
                    filterSqlService.parseJsonField(
                        filter.getMetaJsonField(), filter.getTargetField(), null, parent);
              } else {
                object =
                    filterSqlService.parseMetaField(
                        filter.getMetaField(), filter.getTargetField(), null, parent, true);
              }

              if (object instanceof MetaField) {
                fieldStr = getMetaSearchField(fieldStr, (MetaField) object);
              } else {
                fieldStr = getJsonSearchField(fieldStr, (MetaJsonField) object);
              }

              searchFields.add(fieldStr + "\" x-required=\"true\" />");
            });
  }

  @Override
  public String getMetaSearchField(String fieldStr, MetaField field) {

    fieldStr = "<field name=\"" + fieldStr + "\" title=\"" + field.getLabel();

    if (field.getRelationship() == null) {
      String fieldType = filterCommonService.getFieldType(field);
      fieldStr += "\" type=\"" + fieldType;
    } else {
      String[] targetRef =
          Beans.get(FilterSqlService.class).getDefaultTarget(field.getName(), field.getTypeName());
      String[] nameField = targetRef[0].split("\\.");
      fieldStr +=
          "\" widget=\"ref-text\" type=\""
              + filterCommonService.getFieldType(targetRef[1])
              + "\" x-target-name=\""
              + nameField[1]
              + "\" x-target=\""
              + metaModelRepo.findByName(field.getTypeName()).getFullName();
    }

    return fieldStr;
  }

  @Override
  public String getJsonSearchField(String fieldStr, MetaJsonField field) {

    FilterSqlService filterSqlService = Beans.get(FilterSqlService.class);

    fieldStr = "<field name=\"" + fieldStr + "\" title=\"" + field.getTitle();

    if (field.getTargetJsonModel() != null) {
      String[] targetRef =
          filterSqlService.getDefaultTargetJson(field.getName(), field.getTargetJsonModel());
      String[] nameField = targetRef[0].split("\\.");
      fieldStr +=
          "\" widget=\"ref-text\" type=\""
              + filterCommonService.getFieldType(targetRef[1])
              + "\" x-target-name=\""
              + nameField[1]
              + "\" x-target=\""
              + MetaJsonRecord.class.getName()
              + "\" x-domain=\"self.jsonModel = '"
              + field.getTargetJsonModel().getName()
              + "'";
    } else if (field.getTargetModel() != null) {
      String[] targetRef =
          filterSqlService.getDefaultTarget(field.getName(), field.getTargetModel());
      String[] nameField = targetRef[0].split("\\.");
      fieldStr +=
          "\" widget=\"ref-text\" type=\""
              + filterCommonService.getFieldType(targetRef[1])
              + "\" x-target-name=\""
              + nameField[1]
              + "\" x-target=\""
              + field.getTargetModel();
    } else {
      String fieldType = Inflector.getInstance().camelize(field.getType(), true);
      fieldStr += "\" type=\"" + fieldType;
    }

    return fieldStr;
  }

  @Override
  public String getTable(String model) {

    String[] models = model.split("\\.");
    MetaModel metaModel = metaModelRepo.findByName(models[models.length - 1]);

    if (metaModel != null) {
      return metaModel.getTableName();
    }

    return null;
  }

  @Override
  @CallMethod
  public String getDefaultTarget(MetaField metaField) {

    if (metaField.getRelationship() == null) {
      return metaField.getName();
    }

    return Beans.get(FilterSqlService.class)
        .getDefaultTarget(metaField.getName(), metaField.getTypeName())[0];
  }

  @Override
  @CallMethod
  public String getDefaultTarget(MetaJsonField metaJsonField) {

    if (!Arrays.asList(MANY_TO_ONE, ONE_TO_ONE, JSON_MANY_TO_ONE)
        .contains(metaJsonField.getType())) {
      return metaJsonField.getName();
    }

    FilterSqlService filterSqlService = Beans.get(FilterSqlService.class);

    if (metaJsonField.getTargetJsonModel() != null) {
      return filterSqlService
          .getDefaultTargetJson(metaJsonField.getName(), metaJsonField.getTargetJsonModel())[0];
    }

    if (metaJsonField.getTargetModel() == null) {
      return metaJsonField.getName();
    }

    return filterSqlService
        .getDefaultTarget(metaJsonField.getName(), metaJsonField.getTargetModel())[0];
  }

  @Override
  @CallMethod
  public String getTargetType(Object object, String target) {

    if (target == null) {
      log.debug("No target provided for target type");
      return null;
    }

    Object targetField = null;
    FilterSqlService filterSqlService = Beans.get(FilterSqlService.class);
    try {
      if (object instanceof MetaJsonField) {
        targetField = filterSqlService.parseJsonField((MetaJsonField) object, target, null, null);
      } else if (object instanceof MetaField) {
        targetField = filterSqlService.parseMetaField((MetaField) object, target, null, null, true);
      }
    } catch (Exception e) {
    }

    if (targetField == null) {
      log.debug("Target field not found");
      return null;
    }

    log.debug("Target field found: {}", targetField);

    return filterSqlService.getTargetType(targetField);
  }
}
